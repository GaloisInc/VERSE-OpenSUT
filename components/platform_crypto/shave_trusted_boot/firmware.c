// @todo check that code makes sense under both 32 and 64 bit models

// Two versions incorporated here based on definition WITH_ATTEST

#include <stddef.h>
#include <string.h>
//#include <stdio.h>

#include "sha_256.h"
#include "reset.h"

//#define WITH_ATTEST 1

#ifdef WITH_ATTEST
// must go in special protected storage (writable only by firmware/hardware)
static byte last_measure[MEASURE_SIZE];  // initial contents unimportant
#endif

#if WAR_CN_284
static unsigned int boot_once;
#else
static unsigned int boot_once __attribute__ ((section (".tbootdata") ));
#endif

#define PARTITION_SIZE 32

int main()
/*$
  requires true;
  requires take b1 = Block<unsigned int>(&boot_once);
  ensures take b2 = Owned<unsigned int>(&boot_once);
$*/
{
  byte loaded_partition[PARTITION_SIZE] = {0};
  const byte expected_measure[MEASURE_SIZE] = {0xAA};
  byte *start_address = &loaded_partition[0];
  byte *end_address = &loaded_partition[PARTITION_SIZE-1];
  void *entry = NULL;

  boot_once = 0;

  int res = reset(start_address, end_address, NULL, entry);

  //res = reset(start_address, end_address, expected_measure, entry);
}

/*$
predicate {bool b} MyPredicate (pointer expected_measure)
{
  if (is_null(expected_measure)) {
    return {b: false};
  } else {
    take a1 = each(i32 j; 0i32 <= j && j < MEASURE_SIZE()) { Owned<int>(array_shift<byte>(expected_measure,j)) };
    return {b: true};
  }
}
$*/

/**
 * Hash the memory region from `start_address` to `end_address` using
 * the SHA256 algorithm. Compare that hash against `expected_measure`.
 * If they are equal and `WITH_ATTEST` is enabled, store the measure
 * into `last_measure`. If they are equal, jump to `entry`.
 */
/*@ requires expected_measure == NULL || \valid_read(expected_measure + (0 .. MEASURE_SIZE-1));
    assigns last_measure[0 .. MEASURE_SIZE-1];
    \valid clause on (start_address .. end_address)
 */
int reset(byte *start_address,
	  byte *end_address,
	  const byte *expected_measure,
    void *entry)
/*$
  requires take b1 = Owned<unsigned int>(&boot_once);
  requires take x = MyPredicate(expected_measure);
  //requires is_null(expected_measure) == true;
  //requires take x =  Owned<byte>(expected_measure);
  ensures take b2 = Owned<unsigned int>(&boot_once);
  //ensures take x1 =  Owned<byte>(expected_measure);
  //ensures is_null(expected_measure);
  ensures take y = MyPredicate(expected_measure);
$*/
{
  // Frama-C doesn't like reasoning about a local variable
#ifndef WITH_ATTEST
  byte last_measure[MEASURE_SIZE];  
#endif


  if (boot_once) {
    return NOT_ALLOWED;
  }

  // compute region size (possibly 0)
  // @todo: is this a legal way to do the pointer subtraction in C?
  size_t region_size = (end_address < start_address) ? 0 : ((size_t) end_address - (size_t) start_address);

  // apply SHA-256 to region 
  SHA256((byte *)start_address,region_size,&last_measure[0]);

  // compare measure to expected measure (if it was provided)
  if ((expected_measure != NULL)
#if !WAR_VERSE_TOOLCHAIN_103
      &&
      (memcmp(last_measure,expected_measure,MEASURE_SIZE) != 0))
#else
    )
#endif
    return HASH_MISMATCH;

  boot_once = 1;

  // CLEAR STATE
  // zero memory outside of region, registers, any other visible state
  // (may require assembler)

#if !WAR_CN_285
  void (*f)() = entry;
  f();
#endif

  // should never reach here
  return 0;
}
  
#ifdef WITH_ATTEST

#include "hmac_sha256.h"
#define KEY_SIZE (32)
#define NONCE_SIZE (16)
#define HMAC_SIZE (32)
  
// must go in special protected storage (read-only, readable only by firmware/hardware)
static byte key[KEY_SIZE]; // how does this get initialized?

/**
 * Perform attestation---checking that a system was booted from a
 * known state in the past---on a system that has been booted with
 * trusted boot. A provisioned key is used to check the attestation
 * and a nonce is provided as part of the attestation protocol. They
 * key is typically provisioned into a specially protected store or is
 * automatically generated by the hardware during fabrication and
 * first initialization. The nonce is typically provided interactively
 * by attestation hardware or a remote protocol.
 *
 * This function only exists if `WITH_ATTEST` is enabled, and can be
 * called after a call to `reset()` has been successfully called, and
 * thus the system's initial state has been measured and the trusted
 * boot process has saved that validated measure in `last_measure`.
 *
 * If `hmac` is non-NULL, perform an HMAC-SHA256 on the catenation of
 * `last_measure` and `nonce` using an externally provisioned and
 * protected `key`.  If `measure` is non-NULL write that HMAC value to
 * `measure`.
 */
/*@ requires hmac == NULL || \valid_read(nonce + (0 .. NONCE_SIZE-1));
    requires measure == NULL || \valid(measure + (0 .. MEASURE_SIZE-1));
    requires hmac == NULL || \valid(hmac + (0 .. HMAC_SIZE-1));
    assigns measure[0 .. MEASURE_SIZE-1] \from last_measure[0 .. MEASURE_SIZE-1];
    assigns hmac[0 .. HMAC_SIZE-1] \from last_measure[0 .. MEASURE_SIZE-1], nonce[0 .. NONCE_SIZE-1], key[0 .. KEY_SIZE-1];
    requires measure == NULL || \separated(measure + (0 .. MEASURE_SIZE-1),last_measure + (0 .. MEASURE_SIZE-1));
    requires hmac == NULL || \separated(hmac + (0 .. HMAC_SIZE-1),last_measure + (0 .. MEASURE_SIZE-1));
    requires measure == NULL || \separated(measure + (0 .. MEASURE_SIZE-1),key + (0 .. KEY_SIZE-1));
    requires hmac == NULL || \separated(hmac + (0 .. HMAC_SIZE-1),key + (0 .. KEY_SIZE-1));
@*/
void attest(const byte *nonce,  // Ignored if hmac == NULL
	    byte *measure,  // IF NULL, do not return measure
	    byte *hmac)  // If NULL, do not return hmac
{

  if (hmac != NULL) {
    // prepare hmac text
    byte hmac_text[MEASURE_SIZE+NONCE_SIZE];
#if !WAR_VERSE_TOOLCHAIN_103
    memcpy(&hmac_text[0],last_measure,MEASURE_SIZE);
    memcpy(&hmac_text[MEASURE_SIZE],nonce,NONCE_SIZE);
#endif

    //do hmac to target buffer
    hmac_sha256(key,KEY_SIZE,hmac_text,MEASURE_SIZE+NONCE_SIZE,hmac);
  }

  if (measure != NULL) {
    //copy out measure to target buffer
#if !WAR_VERSE_TOOLCHAIN_103
    memcpy(measure,last_measure,MEASURE_SIZE);
#endif
  }
}

#endif
